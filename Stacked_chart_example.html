
<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>

<!-- Create a div where the graph will take place -->
<div id="my_dataviz"></div>

<script>


  // set the dimensions and margins of the graph
  var margin = {top: 10, right: 30, bottom: 30, left: 60},
      width = 460 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;
  
  // append the svg object to the body of the page
  var svg = d3.select("#my_dataviz")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
  
  //Read the data
  d3.csv("final_stock.csv",
     // When reading the csv, I must format variables:
    function(d){
      return { stockName : d.StockName, Date : d3.timeParse("%Y-%m-%d")(d.Date),Open : d.Open ,High : d.High,Low : d.Low,Close : d.Close,AdjClose : d.AdjClose,Volume : d.Volume}
    },
    function(data){

    //Seperating into sections our data based on how many stocks we have
    var sections = {};
    data.forEach(function(d) {
        // Assuming 'entry' is the column you want to use to divide the data
        var entry = d3.values(d)[0];
        if (!sections[entry]) {
            sections[entry] = [];
        }
        sections[entry].push(d);
    });

    console.log(sections)

    var varMax = 0
    for (var entry in sections) {
        if (sections.hasOwnProperty(entry)) {
            var sectionData = sections[entry];
            // Find max Close in sectionData
            var maxClose = d3.max(sectionData, function(d) {
                // Assuming 'Close' is the attribute you want to find the maximum of
                return +d.Close; // Convert to number
            });
            //console.log("Max Close in section for entry " + entry + ":", maxClose);
            varMax += maxClose
        }
    }
    //console.log(varMax)

    // group the data: one array for each value of the X axis.
    var sumstat = d3.nest()
      .key(function(d) { return d.Date; })
      .entries(data)
  
    var count = 0
    // Stack the data: each group will be represented on top of each other
    var etfs = ["AAAU", "AADR", "AAXJ"] // list of group names
    var etf = [0,1,2] // list of group names
    var stackedData = d3.stack()
      .keys(etf)
      .value(function(d, key){
        if (typeof d.values[key] !== 'undefined') {
            return d.values[key].Close;
            
        } else {
            
            console.log("FOUND UNDEFINED")
            return 1; // or any default value you prefer
        }
      })
      (sumstat)

      //console.log(stackedData)

    // Add X axis --> it is a date format
    var x = d3.scaleTime()
      .domain(d3.extent(data, function(d) { 
        return (d.Date); }))
      .range([ 0, width ]);
    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x).ticks(5));
  
    // Add Y axis
    var y = d3.scaleLinear()
      .domain([0, varMax*1.1])
      .range([ height, 0 ]);
    svg.append("g")
      .call(d3.axisLeft(y));
  
    // color palette
    var color = d3.scaleOrdinal()
      .domain(etfs)
      .range(['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999'])
    
    // Initialize an array to store the maximum values for each element
    var maxValues = [];

    // Loop through each element
    stackedData.forEach(function(element) {
        // Calculate the maximum value of the second attribute for the current element
        var maxSecondAttribute = d3.max(element, function(d) { return d.Close; });
        // Store the maximum value in the maxValues array
        maxValues.push(maxSecondAttribute);
    });

    // Now, maxValues contains the maximum value of the second attribute for each element
    //console.log(maxValues);  
    //console.log(d3.max(stackedData))

    // Show the areas
    svg
      .selectAll("mylayers")
      .data(stackedData)
      .enter()
      .append("path")
        .style("fill", function(d) { name = etfs[d.key-1] ;  return color(name); })
        .attr("d", d3.area()
          .x(function(d, i) { 
            return x(new Date(d.data.key)); })
          .y0(function(d) { return y(d[0]); })
          .y1(function(d) { return y(d[1]); })
      )
 
  })
  </script>