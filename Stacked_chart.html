
<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://d3js.org/d3.v4.js"></script>

<!-- Create a parent container for the graph and filter -->
<div class="container">
    <!-- Create a div where the graph will take place -->
    <div id="my_dataviz"></div>
    <!-- Create a div for the filter -->
    <div id="filterContainer">
        <!-- Add title for the filter -->
        <div class="filterTitle">Filter by type:</div>
        <!-- Create a div for the checkbox container -->
        <div id="checkboxContainer"></div>
    </div>
</div>

<style>
    /* CSS styling for each checkbox and label pair */
    .checkbox-label {
        display: inline-block;
        margin-right: 10px; /* Adjust spacing between checkbox and label */
    }
    /* CSS styling for parent container */
    .container {
        display: flex;
        flex-direction: row; /* Arrange items horizontally */
    }

    /* CSS styling for filter container */
    #filterContainer {
        display: inline-block; /* Set as inline-block to wrap around contents */
        width: 100px; /* Set width to control position to the right */
        margin-left: 10px; /* Add margin for spacing */
        border: 2px solid lightblue; /* Add light blue border */
        background-color: rgba(173, 216, 230, 0.3); /* Light blue background with low opacity */
        padding: 10px; /* Add padding for spacing */
        max-height: 60px; /* Limit the maximum height */
      overflow-y: auto; /* Add vertical scrollbar if content overflows */
    }

    /* CSS styling for filter title */
    .filterTitle {
        font-weight: bold; /* Make title bold */
    }


</style>

<script>

  var isHighlighted = false;

  // set the dimensions and margins of the graph
  var margin = {top: 10, right: 30, bottom: 30, left: 60},
      width = 460 - margin.left - margin.right,
      height = 400 - margin.top - margin.bottom;
  
  // append the svg object to the body of the page
  var svg = d3.select("#my_dataviz")
    .append("svg")
      .attr("width", width + margin.left + margin.right*2.5)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
  
  //Read the data
  d3.csv("final_stock.csv",
     // When reading the csv, I must format variables:
    function(d){
      return { stockType: d.StockType, stockName : d.StockName, Date : d3.timeParse("%Y-%m-%d")(d.Date), Close : d.Close, holdings : d.Holdings, value : d.Value}
    },
    function(data){

    //Seperating into sections our data based on how many stocks we have
    var sections = {};
    data.forEach(function(d) {
        // Assuming 'entry' is the column you want to use to divide the data
        var entry = d3.values(d)[1];
        if (!sections[entry]) {
            sections[entry] = [];
        }
        sections[entry].push(d);
    });

    var varMax = 0
    function calculateVarMax(filter){
      var varMaxTemp = 0
      for (var entry in filter) {
        if (filter.hasOwnProperty(entry)) {
            var sectionData = filter[entry];
            // Find max Close in sectionData
            var maxValue = d3.max(sectionData, function(d) {
                return +d.value; // Convert to number
            });
            //console.log("Max Close in section for entry " + entry + ":", maxValue);
            varMaxTemp += maxValue
        } 
      }
      return varMaxTemp
    }
    
    varMax = calculateVarMax(sections)
    

    // group the data: one array for each value of the X axis.
    var sumstat = d3.nest()
      .key(function(d) { return d.Date; })
      .entries(data)
  
    
    var count = 0
    var etf = []
    var etfs = []
    for (var entry in sections) {
      etf.push(count)
      etfs.push(entry)
      count++
    }

    function calculateStackedData(filteredData, filteredETF) {
       // Group the filtered data: one array for each value of the X axis.
        // console.log("ETF:")
        // console.log(etf)
        // console.log("Filtered ETF:")
        // console.log(filteredETF)
        // Stack the data: each group will be represented on top of each other
        return d3.stack()
            .keys(filteredETF)
            .value(function(d, key) {
                if (d.values !== undefined && d.values[key] !== undefined) {
                    return +d.values[key].value;
                } else {
                    console.log("FOUND UNDEFINED");
                    return 0; // or any default value you prefer
                }
            })
            (sumstat);
    }

    var stackedData = calculateStackedData(data, etf)
    

    // Add X axis --> it is a date format
    var x = d3.scaleTime()
      .domain(d3.extent(data, function(d) { 
        return (d.Date); }))
      .range([ 0, width ]);
    svg.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x).ticks(5));
  
    // Add Y axis
    var y = d3.scaleLinear()
      .domain([0, varMax])
      .range([ height, 0 ]);
    svg.append("g")
      .call(d3.axisLeft(y));
  
    // color palette
    var color = d3.scaleOrdinal()
      .domain(etfs)
      .range(['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999'])
    

   // Show the areas
    function showAreas(stackedData, y){
      //svg.remove()
        svg
        .selectAll("mylayers")
        .data(stackedData.reverse())
        .enter() 
        .append("path")
          .attr("class", function(d) { return "area area-" + etfs[d.key] }) // Assign a class based on the ETF
          .style("fill", function(d) {  
            console.log(etfs)
            return color(etfs[d.key]); }) // Set fill color based on the ETF
          .attr("d", d3.area()
            .x(function(d, i) { return x(new Date(d.data.key)); })
            .y0(function(d) { return  y(d[0]); })
            .y1(function(d) { return y(d[1]); })
        )
              // Add mouseover and mouseout events to the areas
        .on("mouseover", function(d) {
            // Highlight the current area (increase opacity)
            if (!isHighlighted){
              d3.select(this).style("opacity", 0.8);
              // Highlight the corresponding legend item
              console.log("Over area with key: " + d.key)
              d3.select(".legend-item-" + etfs[d.key]).style("opacity", .7);
            }
        })
        .on("mouseout", function(d) {
          if (!isHighlighted){
            // Restore the opacity when mouse leaves the area
            d3.select(this).style("opacity", 1);
            // Remove highlight from the corresponding legend item
            d3.select(".legend-item-" + etfs[d.key]).style("opacity", 1);
          }
        })
        // Add click event to areas
        .on("click", function(d) {
            var thisArea = this;
            isHighlighted = true
            d3.selectAll(".area")
                .filter(function() { return this !== thisArea; })
                .style("opacity", .3); // Set opacity to 1 for all areas except the clicked one
                d3.selectAll(".legend-item")
                  .style("opacity", .3); 
                d3.selectAll(".legend-item-" + etfs[d.key])
                  .style("opacity", 1); 
            d3.select(this).style("opacity", 1);
        })
        .style("opacity", 0) // Set initial opacity to 0 for the enter selection
        .transition() // Apply transition to smoothly reveal the areas
        .delay(function(d, i) { return i * 100; }) // Add delay to stagger the animation
        .duration(500) // Set the duration of the transition
        .style("opacity", 1); // Transition opacity to 1 to reveal the areas
      
      
    }
    showAreas(stackedData, y)
   

    // Add legend items
    function addLegends(stackedData){
      // Create a legend container
      var legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", "translate(" + (width+10) + ", 20)");
      var legendItems = legend.selectAll(".legend")
          .data(stackedData)
          .enter().append("g")
          .attr("class", function(d) { 
            if(etfs[d.key] !== undefined){
              return "legend-item legend-item-" + etfs[d.key]; // Assign a class based on the ETF
            }
          })
          .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });
       
      // Add colored rectangles (representing series) to legend
      legendItems.append("rect")
          .attr("x", 0)
          .attr("width", 10)
          .attr("height", 10)
          .attr("fill", function(d) { name = etfs[d.key] ; 
            if(etfs[d.key] !== undefined){ 
              return color(name)
            }else {
              return "#FFFFFF" //Turn boxes to white (to make them dissapear if not in filter)
            }; 
          
          }) // Assuming 'color' is your color scale

      // Add text labels to legend
      legendItems.append("text") // Add text within each rectangle
          .attr("x", 20)
          .attr("y", 5)
          .attr("dy", ".35em")
          .text(function(d) {
            if (d[0].data.values[d.key] !== undefined) {
              return d[0].data.values[d.key].stockName;
            } else {
              return null
            }
            
          }); // Use the stock name of the first data point in each series
      
      // Add hover and click events to legend items
      legendItems.on("mouseover", function(d) {
        if (!isHighlighted){
            // Highlight corresponding area in the chart (e.g., increase opacity)
            d3.select(".area-" + etfs[d.key]).style("opacity", 0.8);
            // console.log("Over area: " + etfs[d.key])
        }
        })
        .on("mouseout", function(d) {
          if (!isHighlighted){
            // Remove highlight when mouse leaves legend item
            d3.select(".area-" + etfs[d.key]).style("opacity", 1);
          }
        });  
    }
    addLegends(stackedData)

    // Add x-axis label
    svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom)
        .text("Time");

    // Add y-axis label
    svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("transform", "rotate(-90)")
        .attr("x", -height / 2)
        .attr("y", -margin.left/2)
        .text("Total Value ($)");
    //-90, -30
    // Add chart title
    svg.append("text")
        .attr("class", "title")
        .attr("text-anchor", "middle")
        .attr("x", width / 2)
        .attr("y", margin.top / 2)
        .text("Portfolio Performance");
    // Add event listener to the SVG container to remove highlight when clicking outside of the highlighted area
    svg.on("click", function() {
      // Check if the click target is the SVG container
      if (!d3.event.target.closest(".area"))  {
        if (isHighlighted) {
          // Remove highlight from all areas
          d3.selectAll(".area").style("opacity", 1);
          d3.selectAll(".legend-item").style("opacity", 1);
          // Update isHighlighted flag
          isHighlighted = false;
        }
      }
    });

   // Extract unique stock types
    var uniqueStockTypes = Array.from(new Set(stackedData.map(function(d) {
        return d[0].data.values[d.key].stockType;
    })));

    // Function to update the visualization based on selected stock types
    function updateVisualization() {
        

        // Get an array of selected stock types
        var selectedStockTypes = [];
        d3.selectAll(".stock-filter-checkbox").each(function() {
            if (this.checked) {
                selectedStockTypes.push(this.value);
            }
        });

        // Filter data based on selected stock types
        var filteredData = data.filter(function(d) {
            return selectedStockTypes.includes(d.stockType);
        });
       
        //Seperating into sections our data based on how many stocks we have
        var filteredSections = {};
        filteredData.forEach(function(d) {
            // Assuming 'entry' is the column you want to use to divide the data
            var entry = d3.values(d)[1];
            if (!filteredSections[entry]) {
              filteredSections[entry] = [];
            }
            filteredSections[entry].push(d);
        });
        var filteredETF = []
        var filteredETFS = []
        count = 0
        console.log(sections)
        for (var entry in sections) {
          if(Object.keys(filteredSections).includes(entry)){
            filteredETF.push(count)
            filteredETFS.push(entry)
          }
          count++
        }

         // Recalculate any necessary variables or scales based on the filtered data
        var filteredStackedData = calculateStackedData(filteredData, filteredETF);


        var filteredVarMax = calculateVarMax(filteredSections);
        // Update X and Y scales, if necessary

        //Remove x and y axis
        svg.selectAll("g").remove();

       // Add X axis --> it is a date format
        x = d3.scaleTime()
          .domain(d3.extent(filteredData, function(d) { 
            return (d.Date); }))
          .range([ 0, width ]);
        svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x).ticks(5));
      
        // Add Y axis
        y = d3.scaleLinear()
          .domain([0, filteredVarMax])
          .range([ height, 0 ]);
        svg.append("g")
          .transition()
          .call(d3.axisLeft(y));   

      // Update areas with filtered and stacked data
      svg.selectAll(".area")
          .data(stackedData)
          .transition()
          .style("opacity", 0)
          .remove();

      showAreas(filteredStackedData, y)

      // Update legend with filtered data
      addLegends(filteredStackedData);
    }

    // Select the container where checkboxes will be appended
    var checkboxContainer = d3.select("#checkboxContainer");

   // Append a checkbox for each unique stock type
    var checkboxes = checkboxContainer.selectAll("input")
        .data(uniqueStockTypes)
        .enter()
        .append("div") // Wrap each checkbox and label in a div
        .each(function(d) { // For each div, append the input and label
            d3.select(this)
                .append("input")
                .attr("type", "checkbox")
                .attr("id", function(d) { return "stock-filter-" + d; })
                .attr("class", "stock-filter-checkbox")
                .attr("value", function(d) { return d; })
                .on("change", updateVisualization); // Add change event listener
            d3.select(this)
                .append("label")
                .attr("for", function(d) { return "stock-filter-" + d; })
                .text(function(d) { return d; });
          });

  })
  </script>